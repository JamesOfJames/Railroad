<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>999</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup

randomize();

// Basics
grid = 32; // Distance between Pixels on grid spacing for basebuilding

selectMode = -1;
buildingSelected = noone;
mobSelected = noone;
spriteSelected = noone;

// Resources
money = 500;
coal = 500;

// Time
paused = false;
timeFactor = 1; // in the future it'd be nice to accel/decel time.
minuteLength = 1000000; // in microseconds
time = 0;
minute = 0;
hour = 0;
day = 0;
year = 0;

// Station Panel
panelStation.uiVisible = false;
autoStationPanel = true;

carCapacity = 0;
carsInUse = 0;

// resource alerts
flashMoney = false;
flashCoal = false;
flashCars = false;

// temporary &amp; testing
alarm_set(1, room_speed * (irandom(15) + 5));
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create Homebase

if room == roomHome
{

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Away Mission Setup

if room == roomAway
{

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Terrain generation
slices = 1;
maxHeight = 64;

heightMap = ds_grid_create(slices, slices);
hm = heightMap;

while (floor(maxHeight) &gt; 6) // the exponent = how many iterations
{for (var a = 0; a &lt;= ds_grid_width(hm) - 1; a += 2)
 {for (var b = 0; b &lt;= ds_grid_height(hm) - 1; b += 2)
  {if (slices == 1)
   {// first iteration, no comparison possible
    ds_grid_set(hm, a, b, irandom(maxHeight * 2));
   }
   else
   {// following iterations, compare and adjust
    var sum, count, checkAbove, checkBelow, checkLeft, checkRight, add;
    sum = 0;
    count = 0;
    checkAbove = false;
    checkBelow = false;
    checkLeft = false;
    checkRight = false;
    if (a &gt; 0) {checkLeft = true;}
    if (a &lt; ds_grid_width(hm) - 1) {checkRight = true;}
    if (b &gt; 0) {checkAbove = true;}
    if (b &lt; ds_grid_height(hm) - 1) {checkBelow = true;}
    
    if (checkAbove)
    {add = ds_grid_get(hm, a, b - 1);
     if (add &gt;= 0) {sum += add;  count++;}
     if (checkLeft)
     {add = ds_grid_get(hm, a - 1, b - 1);
      if (add &gt;= 0) {sum += add;  count++;}}
     if (checkRight)
     {add = ds_grid_get(hm, a + 1, b - 1);
      if (add &gt;= 0) {sum += add;  count++;}}}
      
    if (checkBelow)
    {add = ds_grid_get(hm, a, b + 1);
     if (add &gt;= 0) {sum += add;  count++;}
     if (checkLeft)
     {add = ds_grid_get(hm, a - 1, b + 1);
      if (add &gt;= 0) {sum += add;  count++;}}
     if (checkRight)
     {add = ds_grid_get(hm, a + 1, b + 1);
      if (add &gt;= 0) {sum += add;  count++;}}}
      
    if (checkLeft)
    {add = ds_grid_get(hm, a - 1, b);
     if (add &gt;= 0) {sum += add;  count++;}}

    if (checkRight)
    {add = ds_grid_get(hm, a + 1, b);
     if (add &gt;= 0) {sum += add;  count++;}}
     
    var avg = sum / count;
    ds_grid_set(hm, a, b, round(avg + irandom(maxHeight)));
      
   }
 
  }
 }
 
/* show_debug_message("slice " + slices);
  
var line = "["
 for (var c = 0; c &lt; ds_grid_width(hm); c++)
 {for (var d = 0; d &lt; ds_grid_height(hm); d++)
  {line += " " + ds_grid_get(hm, c, d);
   if (median(-1, ds_grid_get(hm, c, d), 10) == ds_grid_get(hm, c, d))
   {line += " ";}}
  show_debug_message(line + " ]");
  line = "[";}*/
 
 
 // cut the slices &amp; height change in half before you start again
 slices *= 2;
 maxHeight /= 2;
 
 // double the grid size
 var cc = ds_grid_width(hm);
 var dd = ds_grid_height(hm);
 ds_grid_resize(hm , cc + slices, dd + slices);
 
 // space out the data to every other row
 for (var c = cc - 1; c &gt;= 0; c--)
 {for (var d = dd - 1; d &gt;= 0; d--)
  {ds_grid_set(hm, (c * 2) + 1 , (d * 2) + 1, ds_grid_get(hm, c, d));
   ds_grid_set(hm, c, d, -1);}}
   
 for (var c = 0; c &lt; ds_grid_width(hm); c += 2)
 {ds_grid_set_region(hm, c, 0, c, ds_grid_height(hm) - 1, -1);}
 for (var d = 0; d &lt; ds_grid_height(hm); d += 2)
 {ds_grid_set_region(hm, 0, d, ds_grid_width(hm) - 1, d, -1);}

/*show_debug_message("slice " + slices);
  
var line = "["
 for (var c = 0; c &lt; ds_grid_width(hm); c++)
 {for (var d = 0; d &lt; ds_grid_height(hm); d++)
  {line += " " + ds_grid_get(hm, c, d);
   if (median(-1, ds_grid_get(hm, c, d), 10) == ds_grid_get(hm, c, d))
   {line += " ";}}
  show_debug_message(line + " ]");
  line = "[";}*/
}

  
for (var a = 0; a &lt; ds_grid_width(hm); a++)
{for (var b = 0; b &lt; ds_grid_height(hm); b++)  
 {var sum, count, checkAbove, checkBelow, checkLeft, checkRight, add;
  sum = 0;
  count = 0;
  checkAbove = false;
  checkBelow = false;
  checkLeft = false;
  checkRight = false;
  if (a &gt; 0) {checkLeft = true;}
  if (a &lt; ds_grid_width(hm) - 1) {checkRight = true;}
  if (b &gt; 0) {checkAbove = true;}
  if (b &lt; ds_grid_height(hm) - 1) {checkBelow = true;}
    
    if (checkAbove)
    {add = ds_grid_get(hm, a, b - 1);
     if (add &gt;= 0) {sum += add;  count++;}
     if (checkLeft)
     {add = ds_grid_get(hm, a - 1, b - 1);
      if (add &gt;= 0) {sum += add;  count++;}}
     if (checkRight)
     {add = ds_grid_get(hm, a + 1, b - 1);
      if (add &gt;= 0) {sum += add;  count++;}}}
      
    if (checkBelow)
    {add = ds_grid_get(hm, a, b + 1);
     if (add &gt;= 0) {sum += add;  count++;}
     if (checkLeft)
     {add = ds_grid_get(hm, a - 1, b + 1);
      if (add &gt;= 0) {sum += add;  count++;}}
     if (checkRight)
     {add = ds_grid_get(hm, a + 1, b + 1);
      if (add &gt;= 0) {sum += add;  count++;}}}
      
    if (checkLeft)
    {add = ds_grid_get(hm, a - 1, b);
     if (add &gt;= 0) {sum += add;  count++;}}

    if (checkRight)
    {add = ds_grid_get(hm, a + 1, b);
     if (add &gt;= 0) {sum += add;  count++;}}
     
    var avg = sum / count;
    ds_grid_set(hm, a, b, round(avg + irandom(maxHeight)));}}
    
/*show_debug_message("INITIAL");
  
var line = "["
 for (var c = 0; c &lt; ds_grid_height(hm); c++)
 {for (var d = 0; d &lt; ds_grid_width(hm); d++)
  {line += " " + ds_grid_get(hm, d, c);
   if (median(-1, ds_grid_get(hm, d, c), 10) == ds_grid_get(hm, d, c))
   {line += " ";}}
  show_debug_message(line + " ]");
  line = "[";}    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Coast generation

var f = ds_grid_get_min(hm, 0, 0, hmW - 1, hmH - 1);
ds_grid_add_region(hm, 0, 0, hmW - 1, hmH - 1, - f);
f = ds_grid_get_max(hm, 0, 0, hmW - 1, hmH - 1);

var hmW = ds_grid_width(hm);
var hmH = ds_grid_height(hm); 

waterMap = ds_grid_create(hmW, hmH);
wm = waterMap;
ds_grid_clear(wm, 0);

// how many coasts?
var coasts = 1;
for (var a = 0; a &lt; 2; a++)
{if (irandom(2) == 0)
 {coasts++;}
 else
 {break;}}
var z = coasts;
// you should always have one, maybe have two, and never more than three coastlines.

var border = ds_grid_create(4, 1);
ds_grid_set(border, 0, 0, ds_grid_get_sum(hm, hmW - 1, 0, hmW - 1, hmH - 1) / hmH); // right 
ds_grid_set(border, 1, 0, ds_grid_get_sum(hm, 0, 0, hmW - 1, 0) / hmW); // top
ds_grid_set(border, 2, 0, ds_grid_get_sum(hm, 0, 0, 0, hmH - 1) / hmH); // left
ds_grid_set(border, 3, 0, ds_grid_get_sum(hm, 0, hmH - 1, hmW - 1, hmH - 1) / hmW); // bottom

// find the lowest coast, and slope down towards that border
while (coasts &gt; 0)
{var d = -1;
 var i = (ds_grid_get_max(hm, hmW - 1, 0, hmW - 1, hmH - 1) - ds_grid_get_min(hm, hmW - 1, 0, hmW - 1, hmH - 1)) / min(hmW, hmH);
 var c = ds_grid_value_x(border, 0, 0, 3, 0, ds_grid_get_min(border, 0, 0, 3, 0));
 switch (c)
 {case 0: // right coast
   for (var b = round(hmW * 1 / 3); b &lt; hmW; b++)
   {for (var e = 0; e &lt; hmH; e++)
    {var f = ds_grid_get(wm, b, e)
     if (f &gt; round(d * i * 2))
     {ds_grid_set(wm, b, e, round(d * i * 2));}}
      d--;}
   break;
  case 1: // top coast
   for (var b = round(hmH * 2 / 3); b &gt;= 0; b--)
   {for (var e = 0; e &lt; hmW; e++)
    {var f = ds_grid_get(wm, e, b)
     if (f &gt; round(d * i * 2))
     {ds_grid_set(wm, e, b, round(d * i * 2));}}
      d--;}
   break;
  case 2: // left coast
   for (var b = round(hmW * 2 / 3); b &gt;= 0; b--)
   {for (var e = 0; e &lt; hmH; e++)
    {var f = ds_grid_get(wm, b, e)
     if (f &gt; round(d * i))
     {ds_grid_set(wm, b, e, round(d * i));}}
      d--;}
   break;
  case 3: // bottom coast
  default:
   for (var b = round(hmW * 1 / 3); b &lt; hmH; b++)
   {for (var e = 0; e &lt; hmW; e++)
    {var f = ds_grid_get(wm, e, b)
     if (f &gt; round(d * i))
     {ds_grid_set(wm, e, b, round(d * i * 2));}}
      d--;}
   break;}
   
 // get ready to loop again
 coasts--;
 ds_grid_add(border, c, 0, 999999); // so it doesn't show up as the minimum again
}

ds_grid_add_grid_region(hm, wm, 0, 0, hmW - 1, hmH - 1, 0, 0);
f = ds_grid_get_min(hm, 0, 0, hmW - 1, hmH - 1);
ds_grid_add_region(hm, 0, 0, hmW - 1, hmH - 1, - f);

// now that coasts are relatively level, add this to the heightMap and clear it back to 0

/*
show_debug_message("LOWERED");
  
var line = "["
 for (var c = 0; c &lt; ds_grid_width(hm); c++)
 {for (var d = 0; d &lt; ds_grid_height(hm); d++)
  {line += " " + ds_grid_get(hm, c, d);
   if (median(-1, ds_grid_get(hm, c, d), 10) == ds_grid_get(hm, c, d))
   {line += " ";}}
  show_debug_message(line + " ]");
  line = "[";}    
  
*/

ds_grid_clear(wm, 0);

wmArea = hmW * hmH;
water = 0.1; // how much of the map should be sea level water?

// while not enough of the map is sea level water
f = ds_grid_get_min(hm, 0, 0, hmW - 1, hmH - 1);
while (ds_grid_get_sum(wm, 0, 0, hmW - 1, hmH - 1) &lt; wmArea * water)
{// while the lowest elevation still exists somewhere
 while (ds_grid_value_exists(hm, 0, 0, hmW - 1, hmH - 1, f))
 {var g = ds_grid_value_x(hm, 0, 0, hmW - 1, hmH - 1, f);
  var h = ds_grid_value_y(hm, 0, 0, hmW - 1, hmH - 1, f);
  ds_grid_set(wm, g, h, 1);
  ds_grid_add(hm, g, h, -1); // so it won't be found in search again
 }
 f++;
}

// re-code the actual sea
// 999999 or greater = a coast
var j, k;
if (ds_grid_get(border, 0, 0) &gt;= 999999) // right 
{ds_grid_multiply_region(wm, hmW - 1, 0, hmW - 1, hmH - 1, 2);
 j = 1; k = 0;}
if (ds_grid_get(border, 1, 0) &gt;= 999999) // top 
{ds_grid_multiply_region(wm, 0, 0, hmW - 1, 0, 2);
 j = 0; k = -1;}
if (ds_grid_get(border, 2, 0) &gt;= 999999) // left 
{ds_grid_multiply_region(wm, 0, 0, 0, hmH - 1, 2);
 j = -1; k = 0;}
if (ds_grid_get(border, 3, 0) &gt;= 999999) // bottom 
{ds_grid_multiply_region(wm, 0, hmH - 1, hmW - 1, hmH - 1, 2);
 j = 0; k = 1;}
 
if (j == 0)
{// go by rows
 if k == -1
 {k = 0;
  var kk = hmH;}
 else
 {k = hmH - 1;
  var kk = -1;}

 while (k != kk)
 {for (j = 0; j &lt; hmW; j++)
  {if ds_grid_get(wm, j, k) &gt; 1
   {ds_grid_multiply_region(wm, max(j - 1, 0), k, min(j + 1, hmW - 1), k, 2);
    ds_grid_multiply_region(wm, j, max(k - 1, 0), j, min(k + 1, hmH - 1), 2);}}
  k += sign(kk);}}
else
{// go by columns
 if j == -1
 {j = 0;
  var jj = hmW;}
 else
 {j = hmW - 1;
  var jj = -1;}

 while (j != jj)
 {for (k = 0; k &lt; hmH; k++)
  {if ds_grid_get(wm, j, k) &gt; 1
   {ds_grid_multiply_region(wm, max(j - 1, 0), k, min(j + 1, hmW - 1), k, 2);
    ds_grid_multiply_region(wm, j, max(k - 1, 0), j, min(k + 1, hmH - 1), 2);}}
  j += sign(jj);}}


// whatcha got
/*show_debug_message("COASTS - " + z);
  
var line = "["
 for (var c = 0; c &lt; ds_grid_height(hm); c++)
 {for (var d = 0; d &lt; ds_grid_width(hm); d++)
  {line += " " + ds_grid_get(wm, d, c);
   if (median(-1, ds_grid_get(wm, d, c), 10) == ds_grid_get(wm, d, c))
   {line += " ";}}
  show_debug_message(line + " ]");
  line = "[";}*/
  
// this should connect disconnected low-lying water, but it...doesn't?
  
ds_grid_multiply_region(wm, 0, 0, hmW -1, hmH -1, 3);

while (ds_grid_value_exists(wm, 0, 0, hmW - 1, hmH - 1, 3))
{
var a = ds_grid_value_x(wm, 0, 0, hmW - 1, hmH - 1, 3);
var b = ds_grid_value_y(wm, 0, 0, hmW - 1, hmH - 1, 3); 
//show_debug_message("river source @ " + a + ", " + b);

{while (ds_grid_get(wm, a, b) &lt; 6)
{
 if (ds_grid_get(wm, a, b) &gt; 5)
 {break;}
 else
 {ds_grid_set(wm, a, b, 2);
//  show_debug_message("river " + a + ", " + b);
}

 // how many spots around this one are off the map?
 blanks = 0;
 if (a == 0 or a == hmW - 1)
 {blanks += 3;
  break;
  if (b == 0 or b == hmH - 1)
  {blanks += 2;}}
 else
 {if (b == 0 or b == hmH - 1)
  {blanks += 3;
    break;
  }}
 if (irandom(8) &lt; blanks)
 {break;}

 var d = a;
 var e = b;
 while (d == a and e == b)
 {var c = ds_grid_get_min(hm, max(0, a - 1), max(0, b - 1), min(hmW - 1, a + 1), min(hmH - 1, b + 1));
  d = ds_grid_value_x(hm, max(0, a - 1), max(0, b - 1), min(hmW - 1, a + 1), min(hmH - 1, b + 1), c);
  e = ds_grid_value_y(hm, max(0, a - 1), max(0, b - 1), min(hmW - 1, a + 1), min(hmH - 1, b + 1), c);
//  show_debug_message("considering " + d + ", " + e);
  if (d == a and e == b)
  {ds_grid_add(hm, a, b, 1);}
  else
  {a = d;
   b = e;
   d = -1;
   e = -1;}}}

while (ds_grid_value_exists(wm, 0, 0, hmW - 1, hmH - 1, 2))
{var f = ds_grid_value_x(wm, 0, 0, hmW - 1, hmH - 1, 2);
 var g = ds_grid_value_y(wm, 0, 0, hmW - 1, hmH - 1, 2);
 ds_grid_set(wm, f, g, 6);
}}}

for (var xx = 0; xx &lt; hmW; xx++)
{for (var yy = 0; yy &lt; hmH; yy++)
 {if (ds_grid_get(wm, xx, yy) &gt; 0)
  {ds_grid_set(wm, xx, yy, 1)}}}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// River generation

//disabled for now while i fix low-lying waters not on the coast.

var hmW = ds_grid_width(hm);
var hmH = ds_grid_height(hm); 

var slices = 1;
while (slices &lt;= 4) // for now.
{for (var h = 0; h &lt; slices; h++)
 {for (var i = 0; i &lt; slices; i++)
{// find a spot not already coastal water
do
{var j = max(0, floor(h / slices * hmW));
 var k = max(0, floor(i / slices * hmH));
 var l = min(floor((h + 1) / slices * hmW), hmW - 1);
 var m = min(floor((i + 1) / slices * hmH), hmH - 1);

// if there's any dry land in this slice
if (ds_grid_value_exists(wm, j, k, l, m, 0))
{var a = irandom_range(j, l);
 var b = irandom_range(k, m);}
else
{break;}}
until (ds_grid_get(wm, a, b) == 0)

//show_debug_message("river source @ " + a + ", " + b);

{while (ds_grid_get(wm, a, b) != 1)
{
 if (ds_grid_get(wm, a, b) == 1)
 {break;}
 else
 {ds_grid_set(wm, a, b, 2);}

 // how many spots around this one are off the map?
 blanks = 0;
 if (a == 0 or a == hmW - 1)
 {blanks += 3;
  break;
  if (b == 0 or b == hmH - 1)
  {blanks += 2;}}
 else
 {if (b == 0 or b == hmH - 1)
  {blanks += 3;
    break;
  }}
 if (irandom(8) &lt; blanks)
 {break;}

 var d = a;
 var e = b;
 while (d == a and e == b)
 {var c = ds_grid_get_min(hm, max(0, a - 1), max(0, b - 1), min(hmW - 1, a + 1), min(hmH - 1, b + 1));
  d = ds_grid_value_x(hm, max(0, a - 1), max(0, b - 1), min(hmW - 1, a + 1), min(hmH - 1, b + 1), c);
  e = ds_grid_value_y(hm, max(0, a - 1), max(0, b - 1), min(hmW - 1, a + 1), min(hmH - 1, b + 1), c);
  
  if (d == a and e == b)
  {ds_grid_add(hm, a, b, 1);}
  else
  {a = d;
   b = e;
   d = -1;
   e = -1;}}}

while (ds_grid_value_exists(wm, 0, 0, hmW - 1, hmH - 1, 2))
{var f = ds_grid_value_x(wm, 0, 0, hmW - 1, hmH - 1, 2);
 var g = ds_grid_value_y(wm, 0, 0, hmW - 1, hmH - 1, 2);
 ds_grid_set(wm, f, g, 1);
}}}}
slices *= 2;
}
  
/*show_debug_message("RIVER");
  
var line = "["
 for (var c = 0; c &lt; ds_grid_width(hm); c++)
 {for (var d = 0; d &lt; ds_grid_height(hm); d++)
  {line += " " + ds_grid_get(wm, c, d);
   if (median(-1, ds_grid_get(wm, c, d), 10) == ds_grid_get(wm, c, d))
   {line += " ";}}
  show_debug_message(line + " ]");
  line = "[";}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Tree generation

var hmW = ds_grid_width(hm);
var hmH = ds_grid_height(hm); 

f = ds_grid_get_max(hm, 0, 0, hmW - 1, hmH - 1);

treeMap = ds_grid_create(hmW, hmH);
tm = treeMap;


var minH = 0;
var count = 0;
for (var a = 0; a &lt; hmW; a++)
{for (var b = 0; b &lt; hmH; b++)
 {if (ds_grid_get(wm, a, b) &gt; 0)
  {minH += ds_grid_get(hm, a, b);
   count++;}}}
minH = round(minH / count); // average height of wet terrain, no trees at this level
var maxH = ds_grid_get_max(hm, 0, 0, hmW - 1, hmH - 1); // max height, trees happy here.

// make the TM into a negative heightmap, so we can fill in forests from the minimum mountain peaks on up

ds_grid_set_grid_region(tm, hm, 0, 0, hmW - 1, hmH - 1, 0, 0);
var tMin = ds_grid_get_min(tm, 0, 0, hmW - 1, hmH - 1);

while (tMin &lt; 0)
{var tx = ds_grid_value_x(tm, 0, 0, hmW - 1, hmH - 1, tMin);
 var ty = ds_grid_value_y(tm, 0, 0, hmW - 1, hmH - 1, tMin);
 ds_grid_set(tm, tx, ty, 0);
 tMin = ds_grid_get_min(tm, 0, 0, hmW - 1, hmH - 1);}

ds_grid_multiply_region(tm, 0, 0, hmW - 1, hmH - 1, -1);

// start filling trees from mountain peaks down.
tMin = ds_grid_get_min(tm, 0, 0, hmW - 1, hmH - 1);

while (tMin &lt; -minH)
{var tx = ds_grid_value_x(tm, 0, 0, hmW - 1, hmH - 1, tMin);
 var ty = ds_grid_value_y(tm, 0, 0, hmW - 1, hmH - 1, tMin);
 
 if random(1) &lt;= ((abs(tMin) - minH) / (maxH - minH))
 {if (ds_grid_get(wm, tx, ty) &lt; 1)
  {//show_debug_message("no water at " + tx + ", " + ty + " - " + ds_grid_get(wm, tx, ty));
   ds_grid_set(tm, tx, ty, 1);}
  else
  {ds_grid_set(tm, tx, ty, 0);}}
 else
 {ds_grid_set(tm, tx, ty, 0);}
  
 if (!ds_grid_value_exists(tm, 0, 0, hmW - 1, hmH - 1, tMin))
 {tMin = ds_grid_get_min(tm, 0, 0, hmW - 1, hmH - 1);}}
 
// fill in trees around water
for (var tx = 0; tx &lt; hmW; tx++)
{for (var ty = 0; ty &lt; hmH; ty++)
 {if ds_grid_get(wm, tx, ty) &gt; 0
  {// there's water here
   for (var xx = max(0, tx - 1); xx &lt; min(tx + 1, hmW - 1); xx++)
   {for (var yy = max(0, ty - 1); yy &lt; min(ty + 1, hmH - 1); yy++)
    {if (ds_grid_get(wm, xx, yy) &lt; 1)
     {if random(1) &lt;= ((abs(ds_grid_get(hm, xx, yy)) - minH) / (maxH - minH)) + .25 // make it more likely to fill in coasts
      {ds_grid_add(tm, xx, yy, 1);}}}}}}}

// fill in trees around trees
for (var tx = 0; tx &lt; hmW; tx++)
{for (var ty = 0; ty &lt; hmH; ty++)
 {if ds_grid_get(wm, tx, ty) == 0
  {if ds_grid_get(tm, tx, ty) == 0
   {// no trees here, but how many around?
    var count = 0;
    for (var xx = max(0, tx - 1); xx &lt; min(tx + 1, hmW - 1); xx++)
    {for (var yy = max(0, ty - 1); yy &lt; min(ty + 1, hmH - 1); yy++)
     {if (ds_grid_get(tm, xx, yy) &gt; 0) 
      {count++;}}}
 
    while (count &gt; 0)
    {if random(1) &lt;= ((abs(ds_grid_get(hm, xx, yy)) - minH) / (maxH - minH)) - .25 // make it less likely to fill in forests
     {ds_grid_add(tm, tx, ty, 1);}
     count--;}}}}}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite generation

var hmmin, hmmax, right, bottom;
right = ds_grid_width(hm) - 1;
bottom = ds_grid_height(hm) - 1;

var a = 1;
while (2 ^ a &lt; right)
{a++;}
right = 2 ^ a;

var b = 1;
while (2 ^ b &lt; bottom)
{b++;}
bottom = 2 ^ b;

heightSurface = surface_create(right, bottom);
waterSurface = surface_create(right, bottom);
treeSurface = surface_create(right, bottom);
//It is highly recommended that all surfaces be created with a size that is a power of 2, ie: 16, 128, 512 or 1024 pixels in size, for example. This is not exactly necessary on certain platforms (like Windows and MacOS) but it will certainly increase compatibility on those targets, while for HTML5 and devices it is essential and very it's important that you remember this or you may run into problems later. 

right = ds_grid_width(hm) - 1;
bottom = ds_grid_height(hm) - 1;

// heightmap
surface_set_target(heightSurface);
hmmin = ds_grid_get_min(hm, 0, 0, right, bottom);
ds_grid_add_region(hm, 0, 0, right, bottom, -hmmin); // min value now should be 0.
hmmax = ds_grid_get_max(hm, 0, 0, right, bottom);

for (var c = 0; c &lt; ds_grid_width(hm); c++)
{for (var d = 0; d &lt; ds_grid_height(hm); d++)
 {draw_set_color(make_colour_hsv(0, 0, 255 * ds_grid_get(hm, c, d) / hmmax));
  draw_point(c, d);}}
  
// watermap
surface_reset_target();
surface_set_target(waterSurface);

for (var c = 0; c &lt;= right; c++)
{for (var d = 0; d &lt;= bottom; d++)
 {draw_set_color(c_blue);
  if ds_grid_get(wm, c, d) &gt; 0
  {draw_point(c, d);}}}
  
// treemap
surface_reset_target();
surface_set_target(treeSurface);

for (var c = 0; c &lt;= right; c++)
{for (var d = 0; d &lt;= bottom; d++)
 {draw_set_color(c_green);
  if ds_grid_get(tm, c, d) &gt; 0
  {draw_point(c, d);}}}
  
surface_reset_target();

// make the sprites
sprite_add_from_surface(spriteMap, heightSurface, 0, 0, surface_get_width(heightSurface), surface_get_height(heightSurface), false, false);
sprite_add_from_surface(spriteMap, waterSurface, 0, 0, surface_get_width(waterSurface), surface_get_height(waterSurface), false, false);
sprite_add_from_surface(spriteMap, treeSurface, 0, 0, surface_get_width(treeSurface), surface_get_height(treeSurface), false, false);

surface_free(heightSurface);
surface_free(waterSurface);
surface_free(treeSurface);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Town Name generation, Calendar months, &amp; Shires
/*

October - wintage / wine, sowing, sugar beet, winter moon, leaves falling
November - mist, winter/autumn, slaughter, blood, fog, pork, sacrifice, cold, leaf-fall, cold
December - frost, dawning / sunshine, begging, snow, holy, winter, midwinterwolves, dark
January â€“ Snowy, Logging, Festive, Fire, Winter
Februrary - rainy, longer days, ice, mud, cakes, horning, gathering, leap month, shit month, unlucky, plunge
March - windy, spring, dry, wild, blossom, birch, childbearing/pregnancy, lying / variable weatehr
April - germinating, easter, grass, oak, 
May - flower, joy, blossom, milk, pasture, budding
June - meadow, fallow, summer, woad, weed, midsummer, first fruits, red/worm fruit, lime/linden tree
July - harvest, hay making, pasture, golden, reaping
August - summer, heat, harvest, corn, flea, weed, what, sickle, wagon
September - fruit, wood, autumn, barley, oats, holy, grape harvest, rutting deer, roaring

Aberdeenshire
Anglesey
Antrim
Argyll
Armagh
Avon
Ayrshire
Banffshire
Bedfordshire
Berkshire
Berwickshire
Brecknockshire
Buckinghamshire
Bute
Caernarfonshire
Caithness
Cardiganshire
Carlow
Carmarthenshire
Cavan
Cheshire
Clackmannanshire
Clare
Cleveland
Clwyd
Cork
Cornwall
Cromarty
Cromartyshire
Cumberland
Cumbria
Denbighshire
Derbyshire
Devon
Donegal
Dorset
Down
Dublin
Dumfriesshire
Dunbartonshire
Durham
Dyfed
Elginshire
Essex
Fermanagh
Fife
Flintshire
Forfarshire
Galway
Glamorgan
Gloucestershire
Gwent
Gwynedd
Haddingtonshire
Hampshire
Herefordshire
Hertfordshire
Humberside
Huntingdonshire
Inverness-shire
Kent
Kerry
Kildare
Kilkenny
Kincardineshire
Kinross-shire
Kirkcudbrightshire
Lanarkshire
Lancashire
Laois
Leicestershire
Leitrim
Limerick
Lincolnshire
Linlithgowshire
Londonderry
Longford
Louth
Mayo
Meath
Merionethshire
Merseyside
Monaghan
Monmouthshire
Montgomeryshire
Nairnshire
Norfolk
Nottinghamshire
Offaly
Orkney
Oxfordshire
Peeblesshire
Pembrokeshire
Perthshire
Peterborough
Powys
Radnorshire
Renfrewshire
Roscommon
Ross-shire
Roxburghshire
Rutland
Selkirkshire
Shetland
Shropshire
Sligo
Somerset
Staffordshire
Stirlingshire
Suffolk
Surrey
Sussex
Sutherland
Tipperary
Tyrone
Warwickshire
Waterford
Wexford
Wicklow
Wigtownshire
Wiltshire
Worcester
Worcestershire
Wrexham
Yorkshire
*/

// Prefixes
prefixes = ds_list_create();
ds_list_add(prefixes, "aber");
ds_list_add(prefixes, "ast");
ds_list_add(prefixes, "auch");
ds_list_add(prefixes, "auchen");
ds_list_add(prefixes, "auchin");
ds_list_add(prefixes, "ach");
ds_list_add(prefixes, "achen");
ds_list_add(prefixes, "achin");
ds_list_add(prefixes, "auchter");
ds_list_add(prefixes, "bal");
ds_list_add(prefixes, "balla");
ds_list_add(prefixes, "bally");
ds_list_add(prefixes, "ball");
ds_list_add(prefixes, "brad");
ds_list_add(prefixes, "bre");
ds_list_add(prefixes, "caer");
ds_list_add(prefixes, "car");
ds_list_add(prefixes, "cul");
ds_list_add(prefixes, "cum");
ds_list_add(prefixes, "dal");
ds_list_add(prefixes, "din");
ds_list_add(prefixes, "dinas");
ds_list_add(prefixes, "dol");
ds_list_add(prefixes, "drum");
ds_list_add(prefixes, "thorp");
ds_list_add(prefixes, "thorpe");
ds_list_add(prefixes, "dun");
ds_list_add(prefixes, "dum");
ds_list_add(prefixes, "don");
ds_list_add(prefixes, "doune");
ds_list_add(prefixes, "fin");
ds_list_add(prefixes, "inver");
ds_list_add(prefixes, "inner");
ds_list_add(prefixes, "kil");
ds_list_add(prefixes, "kin");
ds_list_add(prefixes, "kyle");
ds_list_add(prefixes, "kyles");
ds_list_add(prefixes, "lang");
ds_list_add(prefixes, "nan");
ds_list_add(prefixes, "nans");
ds_list_add(prefixes, "nant");
ds_list_add(prefixes, "nor");
ds_list_add(prefixes, "pol");
ds_list_add(prefixes, "pont");
ds_list_add(prefixes, "porth");
ds_list_add(prefixes, "shep");
ds_list_add(prefixes, "ship");
ds_list_add(prefixes, "stan");
ds_list_add(prefixes, "strath");
ds_list_add(prefixes, "sud");
ds_list_add(prefixes, "sut");
ds_list_add(prefixes, "tilly");
ds_list_add(prefixes, "tullie");
ds_list_add(prefixes, "tulloch");
ds_list_add(prefixes, "wes");
ds_list_add(prefixes, "win");
ds_list_add(prefixes, "vin");
ds_list_add(prefixes, "fin");
ds_list_add(prefixes, "lan");
ds_list_add(prefixes, "pen");
ds_list_add(prefixes, "pit");
ds_list_add(prefixes, "lin");
ds_list_add(prefixes, "lynn");
ds_list_add(prefixes, "king");
ds_list_add(prefixes, "tre");
ds_list_add(prefixes, "moss");
ds_list_add(prefixes, "kirk");
ds_list_add(prefixes, "tra");
ds_list_add(prefixes, "ac");
ds_list_add(prefixes, "acc");
ds_list_add(prefixes, "avon");
ds_list_add(prefixes, "ar");
ds_list_add(prefixes, "ard");
ds_list_add(prefixes, "ash");
ds_list_add(prefixes, "axe");
ds_list_add(prefixes, "exe");
ds_list_add(prefixes, "beck");
ds_list_add(prefixes, "ben");
ds_list_add(prefixes, "beinn");
ds_list_add(prefixes, "beann");
ds_list_add(prefixes, "ban");
ds_list_add(prefixes, "bannau");
ds_list_add(prefixes, "bannock");
ds_list_add(prefixes, "bannog");
ds_list_add(prefixes, "berry");
ds_list_add(prefixes, "bex");
ds_list_add(prefixes, "blen");
ds_list_add(prefixes, "blaen");
ds_list_add(prefixes, "cheap");
ds_list_add(prefixes, "chipping");
ds_list_add(prefixes, "craig");
ds_list_add(prefixes, "crag");
ds_list_add(prefixes, "creag");
ds_list_add(prefixes, "eagles");
ds_list_add(prefixes, "eglos");
ds_list_add(prefixes, "eglews");
ds_list_add(prefixes, "eccles");
ds_list_add(prefixes, "eglwys");
ds_list_add(prefixes, "gar");
ds_list_add(prefixes, "gart");
ds_list_add(prefixes, "glen");
ds_list_add(prefixes, "holm");
ds_list_add(prefixes, "hope");
ds_list_add(prefixes, "sop");
ds_list_add(prefixes, "knock");
ds_list_add(prefixes, "ling");
ds_list_add(prefixes, "pant");
ds_list_add(prefixes, "streat");
ds_list_add(prefixes, "swin");
ds_list_add(prefixes, "weald");

//Suffixes
suffixes = ds_list_create();
ds_list_add(suffixes, "ay");
ds_list_add(suffixes, "beck");
ds_list_add(suffixes, "berg");
ds_list_add(suffixes, "borough");
ds_list_add(suffixes, "bost");
ds_list_add(suffixes, "bourne");
ds_list_add(suffixes, "brough");
ds_list_add(suffixes, "burgh");
ds_list_add(suffixes, "burn");
ds_list_add(suffixes, "bury");
ds_list_add(suffixes, "by");
ds_list_add(suffixes, "carden");
ds_list_add(suffixes, "caster");
ds_list_add(suffixes, "cester");
ds_list_add(suffixes, "ceter");
ds_list_add(suffixes, "chester");
ds_list_add(suffixes, "cheth");
ds_list_add(suffixes, "coed");
ds_list_add(suffixes, "combe");
ds_list_add(suffixes, "coombe");
ds_list_add(suffixes, "cot");
ds_list_add(suffixes, "cott");
ds_list_add(suffixes, "dale");
ds_list_add(suffixes, "dean");
ds_list_add(suffixes, "den");
ds_list_add(suffixes, "don");
ds_list_add(suffixes, "dow");
ds_list_add(suffixes, "dubh");
ds_list_add(suffixes, "duff");
ds_list_add(suffixes, "ey");
ds_list_add(suffixes, "field");
ds_list_add(suffixes, "firth");
ds_list_add(suffixes, "force");
ds_list_add(suffixes, "ford");
ds_list_add(suffixes, "forth");
ds_list_add(suffixes, "fos");
ds_list_add(suffixes, "foss");
ds_list_add(suffixes, "fridd");
ds_list_add(suffixes, "frith");
ds_list_add(suffixes, "garth");
ds_list_add(suffixes, "gate");
ds_list_add(suffixes, "ghyll");
ds_list_add(suffixes, "gill");
ds_list_add(suffixes, "glen");
ds_list_add(suffixes, "gowt");
ds_list_add(suffixes, "ham");
ds_list_add(suffixes, "hay");
ds_list_add(suffixes, "hayes");
ds_list_add(suffixes, "hays");
ds_list_add(suffixes, "hithe");
ds_list_add(suffixes, "holm");
ds_list_add(suffixes, "hurst");
ds_list_add(suffixes, "hythe");
ds_list_add(suffixes, "ing");
ds_list_add(suffixes, "ington");
ds_list_add(suffixes, "keld");
ds_list_add(suffixes, "keth");
ds_list_add(suffixes, "kirk");
ds_list_add(suffixes, "law");
ds_list_add(suffixes, "lea");
ds_list_add(suffixes, "leigh");
ds_list_add(suffixes, "ley");
ds_list_add(suffixes, "lin");
ds_list_add(suffixes, "loch");
ds_list_add(suffixes, "low");
ds_list_add(suffixes, "lyn");
ds_list_add(suffixes, "lynn");
ds_list_add(suffixes, "mere");
ds_list_add(suffixes, "minster");
ds_list_add(suffixes, "more");
ds_list_add(suffixes, "mouth");
ds_list_add(suffixes, "ness");
ds_list_add(suffixes, "ock");
ds_list_add(suffixes, "parva");
ds_list_add(suffixes, "pool");
ds_list_add(suffixes, "port");
ds_list_add(suffixes, "rig");
ds_list_add(suffixes, "rigg");
ds_list_add(suffixes, "shaw");
ds_list_add(suffixes, "stead");
ds_list_add(suffixes, "ster");
ds_list_add(suffixes, "stow");
ds_list_add(suffixes, "stowe");
ds_list_add(suffixes, "street");
ds_list_add(suffixes, "tarn");
ds_list_add(suffixes, "thorp");
ds_list_add(suffixes, "thorpe");
ds_list_add(suffixes, "thwaite");
ds_list_add(suffixes, "toft");
ds_list_add(suffixes, "ton");
ds_list_add(suffixes, "traeth");
ds_list_add(suffixes, "treath");
ds_list_add(suffixes, "tun");
ds_list_add(suffixes, "wich");
ds_list_add(suffixes, "wick");
ds_list_add(suffixes, "wold");
ds_list_add(suffixes, "worth");
ds_list_add(suffixes, "worthy");
ds_list_add(suffixes, "wych");
ds_list_add(suffixes, "wyke");
ds_list_add(suffixes, "y");

ds_list_shuffle(prefixes);
ds_list_shuffle(suffixes);
/*
for (var a = 0; a &lt; 25; a++)
{show_debug_message(ds_list_find_value(prefixes, a) + ds_list_find_value(suffixes, a));}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// engine name generation
/*
red
minister
comrade
citizen?
people
worker
farmer
proletarian
plebian
laborer
commoner
partisan
soldier
artisan
craftsman
stalwart
revolution(ary)
admiral
general
marshal
Commodore
valiant?

voyager
adventurer
pilgrim
explorer
globetrotter
navigator
rambler
roamer
rover
wayfarer
wanderer
ranger
traveler
trailblazer
venturer
protector
defender
vindicator
warrior
martyr
hero
heroine
legend
star
conquerer
vanguard
challenger
defender
advocate
friend
ally
advance
alliance
arrow
spear
sword
lance
javelin
comet
struggle
victory
future
glory
lion
pride
cause
cannon?
runner
carrier
victor
campion
colossus
accord
concord
courier
courser
thoroughbred
dart
dauntless?
dawn
daylight?
defender
defiance
dragon
drake
hind
elk
spirit
falcon
firefly
flier
freedom
fury
battle
Behemoth
Conqueror
Crusader
Deliverance
Dreadnought
Emblem
banner
Envoy
Endurance
Earnest?
Explorer
witness
justice
Fearless
ferocity
fervor
Ferocious
flame
blaze
blazon
Formidable
Gladiator
gunner?
Harrier
radier
harvest
bounty
hawk
Huntress
Huntsman
hurricane
zephyr
thunder
tornado
resolve
Intimidate
Impregnable
Incomparable
Invincible 
Inviolate
Iron
steel
Leviathan 
liberty
lightning
lioness
Lodestar
Mammoth
fellow?
Onslaught
Overlander
Revenge
Tiger
union
war
justice
chariot
boast
hunter
huntress
dream
brave
hope
deliverance
intent
rocket
fireball
camel?
buffalo?
elk?
Defiance
Dromedary 
firebrand
zealot
gazelle
greyhound
hero
heroine
hornet
industry
leopard
lynx
meteor
panther
phoenix
luck
spitfire
titan
victory
victor
wolf
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Cleanup

ds_grid_destroy(heightMap);
ds_grid_destroy(hm);
ds_grid_destroy(waterMap);
ds_grid_destroy(wm);
ds_grid_destroy(treeMap);
ds_grid_destroy(tm);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//fsa
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// spawn an enemy for target practice!

if instance_number(objectEnemy) &lt; 5
{instance_create(irandom(room_width), irandom(room_height), objectEnemy);}

alarm_set(1, room_speed * (irandom(15) + 5));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//nkjkl
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// View Movement

viewBorder = 16;

// View Coords
xView = view_xview[0];
yView = view_yview[0];
wView = view_wview[0];
hView = view_hview[0];

// Mouse Coords
mouseX = mouse_x;
mouseY = mouse_y;

// View movement
if mouseX &lt; xView + viewBorder {view_xview[0]--;}
if mouseX &gt; xView + wView - viewBorder {view_xview[0]++;}
if mouseY &lt; yView + viewBorder {view_yview[0]--;}
if mouseY &gt; yView + hView - viewBorder {view_yview[0]++;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Keep GUI Fixed

// keep the controller in the window
x = view_xview[0] + 64;
y = view_yview[0] + 64;

if (room == roomHome)
{with (panelBuildings)
 {x = view_xview[0];
  y = view_yview[0] + 336;}
 
 with (panelStation)
 {x = view_xview[0] + 64;
  y = view_yview[0] + 64;}}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Resource alerts
/*
if flashMoney
{moneyFC = 8;
 moneyFT = room_speed / 2;
 flashMoney = false;}
if flashCoal
{coalFC = 8;
 coalFT = room_speed / 2;
 flashCoal = false;}
if flashCars
{carsFC = 8;
 carsFT = room_speed / 2;
 flashCars = false;}

moneyFT--;
coalFT--;
carsFT--;
 
if 

coalFC = 8;
carsFC = 8;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Time advances, resource drip

if !paused
{time += (delta_time * timeFactor);

while (time &gt;= minuteLength)
{time -= minuteLength;
 minute += 5;}
while (minute &gt;= 60)
{minute -= 60;
 hour++;}
while (hour &gt;= 24)
{hour -= 24;
 day++;
 coal += instance_number(objectStation) * 8; // hydrogen drip of level 1 desert and fire planets, hardcoded for now.  Make a script to handle eventually.
 }
while (day &gt;= 360)
{day -= 360;
 year++;}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="8">
      <action>
        <libid>1</libid>
        <id>223</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_current_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="6" enumb="51">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Right-Click Actions

if (room == roomHome)
{
// clicked outside station panel, close.
if (panelStation.uiVisible)
{if (!collision_point(mouse_x, mouse_y, panelStation, false, false))
 {panelStation.uiVisible = false;}}

switch (selectMode)
{case 2: // Move train
 {with (mobSelected)
  {if (goal == noone)
   {goal = instance_nearest(mouse_x, mouse_y, parentPlatform);
    var a, b, gx, gy;
    a = path_add();
    gx = goal.x + grid;
    gy = goal.y + grid;
    mp_grid_path(other.mpGrid, a, x, y, gx, gy, false);
    b = path_get_length(a);
//    other.coal -= fuel * b / grid;
    path_delete(a);}
    scriptDeselect();}}
 break;
 default:
 scriptDeselect();
 break;}}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Place Tracks, Trains, etc

if (room == roomHome)
{// clicked outside station panel, close.
if (panelStation.uiVisible)
{if (!collision_point(mouse_x, mouse_y, panelStation, false, false))
 {panelStation.uiVisible = false;}}

switch (selectMode)
{case 0: // Lay tracks &amp; place building
 {if !collision_point(mouse_x, mouse_y, panelBuildings, false, true)
  {if !collision_point(mouse_x, mouse_y, parentBuilding, false, true)
   {var a = instance_create(floor(.5 * mouse_x / grid) * grid * 2, floor(.5 * mouse_y / grid) * grid * 2, buildingSelected);
    with (parentTrack)
    {event_user(0);}
    if (buildingSelected != objectTrack)
    {scriptDeselect();}}}}
 break;
 case 1: // Place Engine
 {if !collision_point(mouse_x, mouse_y, panelBuildings, false, true)
  {if collision_point(mouse_x, mouse_y, objectTrack, false, true)
   {var a = instance_create(grid + floor(.5 * mouse_x / grid) * grid * 2, grid + floor(.5 * mouse_y / grid) * grid * 2, buildingSelected);
    scriptDeselect();}}}
 break;
 default:
 break;}}

/*
if selectMode == 0
{if buildingSelected != noone
 {if mouse_y &lt; panelBuildings.y // In the play area, not GUI Button land
  {if collision_point(round(mouse_x / grid) * grid, round(mouse_y / grid) * grid, objectBuilding, false, true) == noone
   {var a;
    a = instance_create(round(mouse_x / grid) * grid, round(mouse_y / grid) * grid, buildingSelected);
    metal--;
    hydrocarbons--;}}}}
else
{var a;
 a = instance_position(round(mouse_x / grid) * grid, round(mouse_y / grid) * grid, objectBuilding);
 // If the clicked object was a building...
 if a != noone {mobSelected.goal = a;}
 else {var b = mobSelected.moveGoal;
 b.x = mouse_x;
 b.y = mouse_y;
 mobSelected.goal = b;}}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// UI Actions

// Ferry

if other.uiControlName=='FerryAway'
{scriptDeselect();
 room_goto(1);}
if other.uiControlName=='FerryHome'
{scriptDeselect();
 room_goto(0);}

// Build Panel

if other.uiControlName=='Rail'
{scriptDeselect();
 buildingSelected = objectTrack;
 spriteSelected = object_get_sprite(buildingSelected);
 selectMode = 0;}
if other.uiControlName=='Train'
{scriptDeselect();
 buildingSelected = objectTransport;
 spriteSelected = object_get_sprite(buildingSelected);
 selectMode = 1;}
if other.uiControlName=='Yard'
{scriptDeselect();
 buildingSelected = objectYard;
 spriteSelected = object_get_sprite(buildingSelected);
 selectMode = 0;}
if other.uiControlName=='Lab'
{scriptDeselect();
 buildingSelected = objectLab;
 spriteSelected = object_get_sprite(buildingSelected);
 selectMode = 0;}
if other.uiControlName=='Ferry'
{scriptDeselect();
 buildingSelected = objectFerry;
 spriteSelected = object_get_sprite(buildingSelected);
 selectMode = 0;}

  
 
 //next select mode is 3 or more.
   
 /*
if other.uiControlName=='Laboratory'
{scriptDeselect();
 buildingSelected = objectLaboratory;
 spriteSelected = object_get_sprite(buildingSelected);
 selectMode = 0;}
if other.uiControlName=='VTOLHangar'
{scriptDeselect();
 buildingSelected = objectVTOLHangar;
 spriteSelected = object_get_sprite(buildingSelected);
 selectMode = 0;}*/
 
// Station Panel

if other.uiControlName == 'CloseStation'
{panelStation.uiVisible = false;}
if (listboxCargo.itemindex != -1)
{if other.uiControlName == 'LoadType'
 {scriptLoadCargo(panelStation.engine, panelStation.station, listboxCargo.itemindex + 1, 0);}
 if other.uiControlName == 'LoadDestination'
 {scriptLoadCargo(panelStation.engine, panelStation.station, listboxCargo.itemindex + 1, 1);}
 if other.uiControlName == 'LoadValue'
 {scriptLoadCargo(panelStation.engine, panelStation.station, listboxCargo.itemindex + 1, 2);}
 if other.uiControlName == 'LoadTime'
 {scriptLoadCargo(panelStation.engine, panelStation.station, listboxCargo.itemindex + 1, 3);}
 if other.uiControlName == 'LoadAvailable'
 {scriptLoadCargo(panelStation.engine, panelStation.station, listboxCargo.itemindex + 1, 4);}
 if other.uiControlName == 'LoadDirection'
 {scriptLoadCargo(panelStation.engine, panelStation.station, listboxCargo.itemindex + 1, 5);}
 if other.uiControlName == 'ListCargo'
 {alarm[0] = room_speed * 2;}}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Map Generation

randomize();

if room == roomHome
{
grid = 16; 

// mp_grid
 
mpGrid = mp_grid_create(-grid / 2, -grid / 2, (room_width + grid) / grid, (room_height + grid) / grid, grid, grid);
mp_grid_add_rectangle(mpGrid, 0, 0, room_width, room_height);

}/*
// Make every cell where both coordinates are even impassable.
var a, b;
for (a = 0; a &lt;= room_width / grid; a++)
 {for (b = 0; b &lt;= room_height / grid; b++)
  {instance_create(a * grid * 2, b * grid * 2, objectBlock);}}

mp_grid_add_instances(mpGrid, objectBlock, false);

with (objectBlock) {instance_destroy();}

// Make the border impassable.
mp_grid_add_rectangle(mpGrid, 0, 0, room_width, 0); // top
mp_grid_add_rectangle(mpGrid, 0, room_height - grid, room_width, room_height - grid); // bottom
mp_grid_add_rectangle(mpGrid, 0, 0, 0, room_height); // left
mp_grid_add_rectangle(mpGrid, room_width, 0, room_width, room_height); // right

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Away Mission Setup

/*

if room == roomAway
{
grid = 32; 

shortSide = 4; // shortest possible room side
longSide = 16; // longest possible room side
spacing = 1; // how much padding to leave b/w rooms
maxSpacing = 6;
doorWidth = 2; // how many spaces to leave for a door

xmin = 0;
xmax = 0;
ymin = 0;
ymax = 0;

var a, b, c, cx, cy, cxx, cyy;
c = self; // start at Controller's coords.

for (b = 0; b &lt; 100; b++)
{// Another room's corners
 cx = c.x / grid;
 cy = c.y / grid;
 cxx = cx + c.image_xscale;
 cyy = cy + c.image_yscale;
 
 // Size the new room 
 xdim = irandom_range(shortSide / 2, longSide / 2) + irandom_range(shortSide / 2, longSide / 2);
 ydim = irandom_range(shortSide / 2, longSide / 2) + irandom_range(shortSide / 2, longSide / 2);

 // Which direction for new room?
 switch irandom(3)
 {case 0:
   xpos = cx - xdim - irandom_range(spacing, maxSpacing);
   ypos = irandom_range(cy - ydim + doorWidth, cyy + ydim - doorWidth);
   break;
  case 1:
   xpos = cxx + irandom_range(spacing, maxSpacing);
   ypos = irandom_range(cy - ydim + doorWidth, cyy + ydim - doorWidth);
   break;
  case 2:
   xpos = irandom_range(cx - xdim + doorWidth, cxx + xdim - doorWidth);
   ypos = cy - ydim - irandom_range(spacing, maxSpacing);
   break;
  case 3:
   xpos = irandom_range(cx - xdim + doorWidth, cxx + xdim - doorWidth);
   ypos = cyy + irandom_range(spacing, maxSpacing);
   break;}
 
 // Check if it's overlapping or too close to other rooms  
 if !collision_rectangle((xpos - spacing) * grid, (ypos - spacing) * grid, (xpos + xdim + spacing) * grid, (ypos + ydim + spacing) * grid, objectBase, false, false)
 {a = instance_create(xpos * grid, ypos * grid, objectBase);
  a.image_xscale = xdim;
  a.image_yscale = ydim;}
 else {b--;}
 
 // Get the bounds of rooms for mpgrid
 xmin = min(xpos, xmin);
 xmax = max(xpos + xdim, xmax);
 ymin = min(ypos, ymin);
 ymax = max(ypos + ydim, ymax);
 
 // Pick another room for the next iteration
 c = instance_find(objectBase, irandom(instance_number(objectBase) - 1));}
 
// mp_grid
 
mpGrid = mp_grid_create(xmin * grid, ymin * grid, xmax - xmin, ymax - ymin, grid, grid);
mp_grid_add_rectangle(mpGrid, xmin * grid, ymin * grid, xmax * grid, ymax * grid);

// Rooms are passable
for (a = 0; a &lt; instance_number(objectBase) - 1; a++)
{b = instance_find(objectBase, a);
 bx = b.x;
 by = b.y;
 bxx = bx + (grid * (b.image_xscale - 1));
 byy = by + (grid * (b.image_yscale - 1));
 mp_grid_clear_rectangle(mpGrid, bx, by, bxx, byy);}
}
 

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move Buildings to dry land

if (instance_number(parentBuilding) &gt; 0)
{with (parentBuilding)
{grid = 2 * control.grid;
 var hmW = ds_grid_width(other.hm);
 var hmH = ds_grid_height(other.hm);

 var sx = floor(x / grid);
 var sy = floor(y / grid);
 var dist = 1;
 
 var looking = true
 while (looking)
 {if ds_grid_value_exists(other.wm, max(0, sx - dist), max(0, sy - dist), min(sx + dist, hmW), min(sy + dist, hmH), 0)
  {sx = ds_grid_value_x(other.wm, max(0, sx - dist), max(0, sy - dist), min(sx + dist, hmW), min(sy + dist, hmH), 0);
   sy = ds_grid_value_y(other.wm, max(0, sx - dist), max(0, sy - dist), min(sx + dist, hmW), min(sy + dist, hmH), 0);}
  else
  {dist++;}
  
  // is there *enough* land here?
  if (ds_grid_get_sum(other.wm, max(0, sx - 1), max(0, sy - 1), min(sx + 1, hmW), min(sy + 1, hmH) &lt;= 5))
  {var count = 0;
   count += ds_grid_get_sum(other.wm, sx, max(0, sy - 1), sx, min(sy + 1, hmH));
   count += ds_grid_get_sum(other.wm, max(0, sx - 1), sy, min(sx + 1, hmW), sy);
   if count &gt; 2
   {dist++;}
   else
   {looking = false;}}
  else
  {dist++;}}
 
 x = sx * grid;
 y = sy * grid;
 
 grid /= 2;
}}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// shaders?
show_debug_message("shaders? - " + shaders_are_supported());
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Cleanup

ds_grid_destroy(heightMap);
ds_grid_destroy(hm);
ds_grid_destroy(waterMap);
ds_grid_destroy(wm);
ds_grid_destroy(treeMap);
ds_grid_destroy(tm);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Resources

// Basic Text Groundwork
draw_set_alpha(1);
draw_set_font(fontArialBlack12);
draw_set_valign(fa_top);

draw_set_halign(fa_right);
draw_set_colour(c_green);
draw_text(view_wview[0] - 8, 8, "Â¤" + string(round(money))); // or maybe Â£

draw_set_colour(c_black);
draw_text(view_wview[0] - 8, 24, string(round(coal)) + "t C");

draw_set_colour(c_dkgray);
draw_text(view_wview[0] - 8, 40, string(round(carsInUse)) + " / " + string(round(carCapacity)) + " cars");

/*
draw_set_halign(fa_left);
draw_set_colour(c_white);
draw_text(8, 8, string(instance_number(objectHuman)) + " / " + string(maxPopulation) + " Pop")
draw_set_colour(c_green);
draw_text(8, 24, string(food) + " Food");

draw_set_halign(fa_right);
draw_set_colour(c_silver);
draw_text(view_wview[0] - 8, 8, string(metal) + " M")
draw_set_colour(c_teal);
draw_text(view_wview[0] - 8, 24, string(hydrocarbons) + " HC");
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw SelectMode
/*
// Basic Text Groundwork
draw_set_alpha(1);
draw_set_font(fontArialBlack12);
draw_set_valign(fa_top);

draw_set_colour(c_black);
draw_set_halign(fa_center);
draw_text(400, 8, string(selectMode));
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Time

// Basic Text Groundwork
draw_set_alpha(1);
draw_set_font(fontArialBlack12);

draw_set_valign(fa_bottom);
draw_set_halign(fa_center);
draw_set_colour(c_black);

if minute &lt; 10
{draw_text(view_wview[0] / 2, view_hview[0] - 32, string(hour) + ":0" + string(floor(minute)));}
else
{draw_text(view_wview[0] / 2, view_hview[0] - 32, string(hour) + ":" + string(floor(minute)));}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Selected Building

if selectMode == 0
{if buildingSelected != noone
 {draw_sprite(spriteSelected, 0, round(mouse_x / grid) * grid , round(mouse_y / grid) * grid);}}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Mob Selected

if selectMode == 1
{if mobSelected != noone
 {draw_sprite(spriteSelected, 0, mobSelected.x, mobSelected.y);}}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Building Selected
/*
if selectMode == 2
{if buildingSelected != noone
 {draw_sprite(spriteSelected, 0, buildingSelected.x, buildingSelected.y);}}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw map

texture_set_interpolation(false);
draw_sprite_ext(spriteMap, 0, 0, 0, grid * 2, grid * 2, image_angle, image_blend, 1);
draw_sprite_ext(spriteMap, 1, 0, 0, grid * 2, grid * 2, image_angle, image_blend, 0.6);
draw_sprite_ext(spriteMap, 2, 0, 0, grid * 2, grid * 2, image_angle, image_blend, 0.6);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// grid stuff - coords etc
/*
draw_set_alpha(1);
draw_set_font(fontArialBlack12);
draw_set_valign(fa_top);

draw_set_halign(fa_left);
draw_set_colour(c_black);
draw_text(mouse_x, mouse_y + 16, string(floor(mouse_x)) + ", " + string(floor(mouse_y)));

draw_set_alpha(0.3);
mp_grid_draw(mpGrid);
draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
