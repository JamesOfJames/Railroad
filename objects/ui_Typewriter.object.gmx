<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_ui</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>0</persistent>
  <parentName>ui_defaults</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Copyright (c) 2016 NailBuster Software Inc. (david@nailbuster.com). All rights reserved.



This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA


*/

event_inherited();
uiDrawBackColor=false;
uiBackColor2=c_silver;   //used for shadows and outlines
canfocus=false;
multLines=false; //local
uiAutoWrap=true;
uiLineSpacing=1;
uiAlignV=fa_top;
uiCenterWrap=true;
uiDrawOutlines=0; //enter number of outlines (0=off, 1=offset 1)  uses uiBackColor2
uiDrawShadows=0; //enter number of outlines (0=off, 1=offset 1)  uses uiBackColor2
uiMemo='';   //set this if you want to wordwrap
items[0]='';   //array of strings in wordwrap
numitems=1;    //wordwrap don't set!
lasttext='';  //backup to check if changed.

curZoomFactor=1;
curAlpha=1;
curRot=0;


scr_gui_setdefaults();         //you should set your default properties in this script.





</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// TextAni Create


/*
Copyright (c) 2016 NailBuster Software Inc. (david@nailbuster.com). All rights reserved.



This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA


*/

event_inherited();

uiPath=-1;
uiPathSpeed=0;
uiPathAbsolute=false;  //follow absolute path or relative path....
uiTypeSpeed=3;
uiAniStart=0;       //just show textart
uiAniDuration=30;
uiAniEnd=0;        //just stop showing


uiAlignV=fa_middle;
uiAlign=fa_center;
uiAlignAni=fa_center;    //usually draw text aligned within control

CurDispText='';
CurStartIndex=1;  //first char in string;
CurInMotion = false;
CurCanDraw = false;
CurAnimated = false;

uiCArray='';
uiCArrayXpos=0;
uiCArrayYpos=0;
uiCArrayRot=0;
uiCArrayZoom=0;
uiCArrayAlpha=0;
uiCArrayColor=0;

//animate stuffs
CurWobble=0;
CurPulse=1;
CurFading=1;
CurSparkle=0;
CurTextWobble=0;
CurTypeIndex=1;
CurAniCounter=1;    //counter for step animation...
uiTextFixed=false;
uiTextEffect=0;  //defaults to same on all chars  1=alternate 2=random;



scr_gui_setdefaults();         //you should set your default properties in this script.

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Label Draw
/*
cury = 0;
curXscale = 1;
curYscale = 1;
/*
Copyright (c) 2016 NailBuster Software Inc. (david@nailbuster.com). All rights reserved.



This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA


*/
/*

if uiViewFixed {
    x = view_xview[view_current]+xstart;
    y = view_yview[view_current]+ystart;
   }

if (uiAniMove) &amp;&amp; (uiMoving) //if currently moving
     {
     with (ui_ani_control)  //remove any animation objects on this widget
         {  if (EaseControl==other.id) &amp;&amp; (EaseKind==0) {instance_destroy();} } 
     uiMoving=false;
     }     

if (uiAniMove) 
               {  EaseKind=0;  //set animation to movement;
                  uiEaseType=uiEaseMoveType;
                  uiEaseDur=uiEaseMoveDur;
                  event_user(12);
                  uiAniMove=false; 
                  uiMoving=true;
               }  
               
                
               
if (uiAnimated) &amp;&amp; (inAnimation=false)
                 {
                 if uiWobble!=0   //wobble is active, create animation
                    {
                        EaseKind=3;
                        uiEaseType=uiEaseWobbleType;
                        uiEaseDur=uiEaseWobbleDur;               
                        event_user(12);                                        
                    }  
                 if uiPulse!=0   //pulse is active, create animation
                    {
                        EaseKind=2;
                        uiEaseType=uiEasePulseType;
                        uiEaseDur=uiEasePulseDur;               
                        event_user(12);                                        
                    }  
                 if uiFading!=0   //fading is active, create animation
                    {
                        EaseKind=4;
                        uiEaseType=uiEaseFadeType;
                        uiEaseDur=uiEaseFadeDur;               
                        event_user(12);                                        
                    }                 
                 if uiGlowing!=0   //fading is active, create animation
                    {
                        EaseKind=6;
                        uiEaseType=uiEaseFadeType;
                        uiEaseDur=uiEaseFadeDur;               
                        event_user(12);                                        
                    }                                     
                 if uiSparkle!=0 //sparkle active, create animation      
                    {
                        EaseKind=5;
                        event_user(12);                                        
                    }                 
                    
                                   
                 inAnimation=true;
                }               
   
if (uiAnimated==false) &amp;&amp; (inAnimation=true) //stop animations
     {
     with (ui_ani_control)  //remove any animation objects on this widget
         {  if EaseControl==other.id {instance_destroy();} } 
     inAnimation=false;
     }              
               
if uiFadeIn 
     {                                                    //fadein
     uiVisible=true;
     if uiAlpha &lt;=1
            {  uiAlpha=uiAlpha+(0.1 * uiFadeSpeed);
               if uiAlpha &gt;0.98 then {     uiAlpha=1;
                                           uiFadeIn=false;
                                     } 
            } 
     }          

if (uiFadeOut &amp;&amp; uiFadeIn==false)
   {  if uiAlpha &gt;=0
            {  uiAlpha=uiAlpha - (0.1 * uiFadeSpeed);
               if uiAlpha &lt;0.02 then {      uiAlpha=0;
                                            uiFadeOut=false;
                                            uiVisible=false;
                                            if killonfade instance_destroy();
                                     } 
               
            } 
   }         
   

    
backalpha=draw_get_alpha();  //restore alpha after draw (drawend)
       
if (uiEnabled==false) || (uiMouseHandle==false) {draw_set_alpha(0.5);} 
     else draw_set_alpha(uiAlpha);  
            


      
if uiSetWidth != -1  {   uiOrigXscale=uiSetWidth/sprite_get_width(sprite_index);   
                         uiOrigWidth=uiSetWidth;
                         uiCurWidth=uiSetWidth;
                         uiSetWidth=-1;
                         image_xscale = uiOrigXscale;
                     }                     

if uiSetHeight != -1 {   uiOrigYscale=uiSetHeight/sprite_get_height(sprite_index);   
                         uiOrigHeight=uiSetHeight;
                         uiCurHeight=uiSetHeight;
                         uiSetHeight=-1;
                         image_yscale= uiOrigYscale;
                     }   
      
                    
if uiZoomOut
   if uiZoomFactor != 0.1
          {  uiZoomFactor= uiZoomFactor * uiZoomSpeed;   
             if uiZoomFactor &lt;= 0.1  {
                                      uiZoomOut=false;               
                                      uiZoomFactor=0.1;
                                     }        
          }    
  
          
if uiPopUp
    {
     uiVisible=true;                   
     EaseKind=7;  //popup zoom
     uiEaseType=30;//37;
     uiEaseDur=30;               
     event_user(12);                                        
     uiPopUp=false;
    }  
if uiPopDown
    {
     EaseKind=8;  //popdown zoom
     uiEaseType=29;
     uiEaseDur=30;               
     event_user(12);                                        
     uiPopDown=false;
    }  
    
                      
if uiZoomIn
   if uiZoomFactor &lt;= 1
          {  uiZoomFactor= uiZoomFactor * (1/uiZoomSpeed);   
             if uiZoomFactor &gt;= 1    {                       //reset to zoom 1
                                      uiZoomIn=false;               
                                      uiZoomFactor=1;
                                      image_xscale = uiOrigXscale * (uiZoomFactor);
                                      image_yscale = uiOrigYscale * (uiZoomFactor);
                                     }        
          }        
      

if (uiAnchor != noone)  //has a parent
   {  
    if uiAnchorPos  //grab relative position of parent
     { 
      x = xstart + ( (uiAnchor).x - (uiAnchor).xstart );
      y = ystart + ( (uiAnchor).y - (uiAnchor).ystart );   
     } 
      uiAlpha=uiAnchor.uiAlpha;   //set alpha for fadein/out effect   
      uiZoomFactor=uiAnchor.uiZoomFactor;  //sets same zoomout/in
      uiAniPulse=uiAnchor.uiAniPulse;
      uiAniFading=uiAniFading;
     if uiAnchorProps     //sets childrens enabled/visible by default.
        { uiEnabled=uiAnchor.uiEnabled &amp;&amp; uiEnabledChild;  
          uiVisible=uiAnchor.uiVisible &amp;&amp; uiVisibleChild;
        }  
     if (depth&gt;=uiAnchor.depth) {depth=uiAnchor.depth-1;}  //children always ahead of parents.
   }
   
  
          
if uiZoomFactor != 1
   {
      image_xscale = uiOrigXscale * (uiZoomFactor);
      image_yscale = uiOrigYscale * (uiZoomFactor);
   }   
                
if (uiHoverMode&gt;0) &amp;&amp; (uiEnabled)  &amp;&amp; (uiCanHover)
  {  
      if position_meeting(mouse_x,mouse_y,self.id)            
       { if isHovering=false {  //first hover
                                isHovering=true;
       
                                if uiHoverMode==1   //hove color mode        
                                   { uiAniFading=1-uiHoverInfo;
                                     uiImageBlend=uiHoverColor;
                                   } else
                                 if uiHoverMode==2  
                                   { EaseKind=9;  //hover zoom in
                                     uiEaseType=37;
                                     uiEaseDur=10;               
                                     event_user(12);                                        
                                   } else
                                 if uiHoverMode==3   //glow affect
                                   {
                                    uiAniDrawGlow=true;
                                   }                                      
                             }
                                   
        } else if isHovering //if we moved off a hovering control;
                {isHovering=false;  //mouseover 
                 curHoverZoom=0;    //reset hoverzoom if applicable    
                 uiAniFading=0;
                 uiImageBlend=c_white;   
                 uiAniDrawGlow=false;
                 if uiHoverMode==2
                    { EaseKind=10;  //hover zoom out
                      uiEaseType=34;
                      uiEaseDur=10;               
                      event_user(12);
                    }                                                           
                }
                
                
                               
  }//if hovermode   
                                      
   
if uiDestroy&gt;=0 {alarm[11]=uiDestroy;   //auto kill        
                 uiDestroy=-1;
                }  
   
if uiDrawSelf then { image_uiXscale=1;
                     image_uiYscale=1; 
                     draw_self();   //allow gms sprites and code as well....     
                   }  

                      
if (uiZoomFactor==0.1) || (uiVisible==false) draw_set_alpha(backalpha);        
   




if (uiZoomFactor==0.1) || (uiVisible==false) exit;  //for zooming     


curZoomFactor=uiZoomFactor+uiAniPulse;
curAlpha=uiAlpha-uiAniFading;
curRot=uiAngle+uiAniWobble;

curXscale=uiXscale+uiAniPulse;
curYscale=uiYscale+uiAniPulse;


draw_set_font(uiFont);
draw_set_halign(uiAlign);
draw_set_valign(uiAlignV);
//draw_set_alpha(curAlpha);


if (uiAniPulse != 0)  &amp;&amp; (uiPulseJello)
   { if uiAniPulse &gt;= 0  {curYscale=(uiYscale)-uiAniPulse;}
               else      {curXscale=(uiXscale)-uiAniPulse;}
   }  
             

if (lasttext!=uiTextValue) //|| (uiAniPulse!=0)  //if string is too long we need to wordwrap
 { 
  lasttext=uiTextValue;  //keep copy to see if changed.

//  if ((string_width(uiTextValue+'X') * curXscale) &gt; (sprite_width)) 
  if ((string_width(uiTextValue+'X')) &gt; (sprite_width))   
   {
     event_user(1); //breaks apart string into items array;
   } else 
       {multLines=false;  //reset if one line fits....
        items=0;
        items[0]=uiTextValue;
        numitems=1;
        };         
 }


if multLines==false {items[0]=uiTextValue;}    //if just one line then just set one array item;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>CurAniCounter +=1;

if uiAnimated
  { uiAnimated=false;
    event_user(0);  
  }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///break apart memo string
var curx,curword, curline, curst,fx,lh;

draw_set_font(uiFont);

curx = 0;
curst=uiTextValue;
curword='';
curline='';
fx=1;
items=0;  //reset items array
drawy=0;  //reset top pos
lastchar='';
while string_length(curst)&gt;fx
 {
 linebreak=false;
 //grab a word (repeat until ' ');
 curchar=string_char_at(curst,fx);
  while 1
     { 
       if (curchar != ' ') &amp;&amp; (curchar != chr(13)) &amp;&amp; (curchar != chr(10)) &amp;&amp; (curchar != '#')
           {curword = curword + curchar;}
       fx=fx+1;
       if fx&gt;string_length(curst) break;
       lastchar=curchar;
       curchar=string_char_at(curst,fx);       
       if (curchar== chr(10)) 
                           {  linebreak=true;                                  
                              break;
                           }                                                                                                 
       if (curchar== '#') {  if (lastchar != '\') {
                                                    linebreak=true;
                                                    break;
                                                  } 
                             else curword =curword+'#';
                          }   
       if (curchar==' ') break;                              
                                                
     }
  curword=curword+' ';
     
  if ((string_width(curline)+string_width(' '+curword))*uiXscale&lt;sprite_width -3)
    {curline=curline+curword;
     curword='';
    }  
    else {  //if line too long we append and create new string.
          items[curx]=curline;
          curx=curx+1;
          curline=curword;
         }
    
  if linebreak  //if chr(10) or '#'
    {
     items[curx]=curline;
     curx=curx+1;
     curline='';
    }
  curword='';            
 }
 
if curline !='' {items[curx]=curline;}

numitems=array_length_1d(items);

if numitems&gt;1 multLines=true else multLines=false;

lh=(string_height('XgpT')*uiYscale);   //lineheight;
uiCurHeight=(numitems * (lh+uiLineSpacing)) + 5;  //info only for other controls.

event_user(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Typewriter effect

var fx,ch;

for (var a = 1; a &lt;= array_length_1d(items); a++)
{



CurDispText=items[a];
CurStartIndex=1; 
CurTypeIndex=1;
      
//clear all arrays
       
uiCArray=0;
uiCArrayXpos=0;
uiCArrayYpos=0;
uiCArrayRot=0;
uiCArrayZoom=0;
uiCArrayAlpha=0;       
uiCArrayColor=0;

for (fx=1;fx&lt;=string_length(CurDispText);fx+=1)
  {
   uiCArray[fx]=string_char_at(CurDispText,fx);
   uiCArrayXpos[fx]=0;
   uiCArrayYpos[fx]=0;
   uiCArrayRot[fx]=0;
   uiCArrayZoom[fx]=uiXscale;
   uiCArrayAlpha[fx]=uiAlpha;                
   uiCArrayColor[fx]=uiTextColor;
   
  }
  
  
CurCanDraw=true;  //can show now...

if (uiWobble != 0) || (uiPulse != 0) || (uiFading != 0)
     {CurAnimated=true;} else {CurAnimated=false;}     
    
     }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Copyright (c) 2016 NailBuster Software Inc. (david@nailbuster.com). All rights reserved.



This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA


*/
/*
var ymargin,disptx,px,py,fx,lh,cury,fg,curXscale,curYscale;

event_inherited();
if (uiZoomFactor==0.1) || (uiVisible==false) exit;  //for zooming     


curZoomFactor=uiZoomFactor+uiAniPulse;
curAlpha=uiAlpha-uiAniFading;
curRot=uiAngle+uiAniWobble;

curXscale=uiXscale+uiAniPulse;
curYscale=uiYscale+uiAniPulse;


draw_set_font(uiFont);
draw_set_halign(uiAlign);
draw_set_valign(uiAlignV);
//draw_set_alpha(curAlpha);


if (uiAniPulse != 0)  &amp;&amp; (uiPulseJello)
   { if uiAniPulse &gt;= 0  {curYscale=(uiYscale)-uiAniPulse;}
               else      {curXscale=(uiXscale)-uiAniPulse;}
   }  
             

if (lasttext!=uiTextValue) //|| (uiAniPulse!=0)  //if string is too long we need to wordwrap
 { 
  lasttext=uiTextValue;  //keep copy to see if changed.

//  if ((string_width(uiTextValue+'X') * curXscale) &gt; (sprite_width)) 
  if ((string_width(uiTextValue+'X')) &gt; (sprite_width))   
   {
     event_user(1); //breaks apart string into items array;
   } else 
       {multLines=false;  //reset if one line fits....
        items=0;
        items[0]=uiTextValue;
        numitems=1;
        };         
 }


if multLines==false {items[0]=uiTextValue;}    //if just one line then just set one array item;


lh=(string_height('XgpT')*curYscale);   //lineheight;
uiCurHeight=(numitems * (lh+uiLineSpacing));  //info only for other controls.



if uiDrawBackColor 
   {
    draw_roundrect_color_ext(x, y, x+sprite_width, y+sprite_height, uiRadiusX,uiRadiusY,uiBackColor,uiBackColor, false);   //fill
   } 

if (uiCenterWrap) || (numitems=1) {ymargin= (sprite_height - (uiCurHeight * curYscale)) div 2 ;} else {ymargin=0;}  //center in area or top

 
if uiAlign==fa_left { px=x +5; } 
 else if uiAlign==fa_middle {px= x + (sprite_width div 2); }
   else if uiAlign==fa_right {px = x+sprite_width -8; } 

   
cury=y+ymargin;   
   
if uiDrawOutlines&gt;0   //draw shadows
   {
    draw_set_color(uiBackColor2);  
     for (fg=1;fg&lt;=uiDrawOutlines;fg+=1)  
       {
        for (fx=0;fx&lt;numitems;fx+=1)   
          {  disptx=items[fx];
             draw_text_transformed(px,cury-fg,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px,cury+fg,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px+fg,cury,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px-fg,cury,disptx,curXscale,curYscale,curRot);                
             draw_text_transformed(px+fg,cury+fg,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px-fg,cury-fg,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px+fg,cury-fg,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px-fg,cury+fg,disptx,curXscale,curYscale,curRot);                
             
             cury=cury+lh+uiLineSpacing;     
          }           
        cury=y+ymargin;    
       }   
   }
   
if uiDrawShadows&gt;0   //draw shadows
   {
    draw_set_color(uiBackColor2);  
     for (fg=1;fg&lt;=uiDrawShadows;fg+=1)  
       {
        for (fx=0;fx&lt;numitems;fx+=1)   
          {  disptx=items[fx];
             draw_text_transformed(px+fg,cury+fg,disptx,curXscale,curYscale,curRot);               
             cury=cury+lh+uiLineSpacing;     
          }           
        cury=y+ymargin;    
       }   
   }   
   


cury=y+ymargin;   

for (fx=0;fx&lt;numitems;fx+=1)   
  {  disptx=items[fx];
     draw_set_color(uiTextColor);  
     draw_text_transformed(px,cury,disptx,curXscale,curYscale,curRot);   
     cury=cury+lh+uiLineSpacing;     
  }   
  
draw_set_alpha(backalpha);  //restore alpha (in case of fadeout, etc     
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw TextAni
/*
var tw,dc,c1, stepx,curp, fx,px,ymargin, curx, cury, angx, angy, ta;

event_inherited();
if (uiZoomFactor==0.1) || (uiVisible==false) exit;  //for zooming     


draw_set_font(uiFont);
draw_set_halign(uiAlign);
draw_set_valign(uiAlignV);



draw_set_color(uiTextColor);

tw=string_length(CurDispText);
if tw==0 exit;

if CurCanDraw==false exit; //arrays not setup yet....

if CurAnimated 
{
     if uiWobble != 0 
          {  
          CurWobble += uiWobbleSpeed;
          if CurWobble &gt; uiWobble  {uiWobbleSpeed *= -1;}                                       
          else if CurWobble &lt; (uiWobble * -1)  {uiWobbleSpeed *= -1;}
          }    
          
     if uiPulse != 0
         {
          CurPulse += uiPulseSpeed;
          if CurPulse &gt; 1+(uiPulse) {uiPulseSpeed *= -1;}
          else if CurPulse &lt; 1-(uiPulse) {uiPulseSpeed *= -1;}          
         } 
         
     if uiFading != 0
         {
          CurFading += uiFadingSpeed;
          if CurFading &gt; 1 {uiFadingSpeed *= -1;}
          else if CurFading &lt; 1-(uiFading) {uiFadingSpeed *= -1;}          
         }             
  

  

    
}     //if has animated things like pulse, fading, etc...
    

if uiFadeOut CurFading=(1-uiAlpha);
  

 {     
       ymargin= (sprite_height - (string_height(CurDispText) * uiYscale)) div 2 ;
       px=x;
       if uiAlignAni==fa_left { px=x +5; } 
         else if uiAlignAni==fa_center {px= x + (( sprite_width-(string_width(CurDispText) * uiYscale)) div 2); }
            else if uiAlignAni==fa_right {px = x + sprite_width - (string_width(CurDispText) * uiYscale) -8; } 
       curp=px;
       for (fx=CurStartIndex;fx&lt;=tw;fx+=1)
            {
                   dc = uiCArray[fx];
                   uiCArrayXpos[fx]=curp;
                   uiCArrayYpos[fx]=y+ymargin;
                   curp += ceil(string_width(dc)*uiCArrayZoom[fx]);
            } 
 
 }  //no path assigned;
 
 
 
 

if uiTextEffect==3  //Type Keypress effect;
    { 
      if (CurAniCounter mod (room_speed div uiTypeSpeed))==1 CurTypeIndex+=1;
      for (fx=1;fx&lt;=tw;fx+=1)  // apply to all characters same;
       {   if fx&gt;=CurTypeIndex {uiCArrayAlpha[fx]=0} else {uiCArrayAlpha[fx]=1;}
       }
    }
    
    
  
//use alpha for keyboard typewriter effect...


 for (fx=CurStartIndex;fx&lt;=tw;fx+=1)  //draw each character individually...
     {
      c1=uiCArrayColor[fx];
      if uiFadeOut uiCArrayAlpha[fx]=uiAlpha;
      draw_text_transformed_color(uiCArrayXpos[fx],uiCArrayYpos[fx],uiCArray[fx],uiCArrayZoom[fx], uiCArrayZoom[fx], uiCArrayRot[fx], c1, c1, c1, c1, uiCArrayAlpha[fx]); 
     } 
 
draw_set_alpha(backalpha);  //restore alpha (in case of fadeout, etc    
 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Combined Draw
/*
var ymargin,disptx,px,py,fx,lh,cury,fg,curXscale,curYscale;
var tw,dc,c1, stepx,curp, fx,px,ymargin, curx, cury, angx, angy, ta;

event_inherited();
if (uiZoomFactor==0.1) || (uiVisible==false) exit;  //for zooming     


draw_set_font(uiFont);
draw_set_halign(uiAlign);
draw_set_valign(uiAlignV);



draw_set_color(uiTextColor);

tw=string_length(CurDispText);
if tw==0 exit;

if CurCanDraw==false exit; //arrays not setup yet....

if CurAnimated 
{
     if uiWobble != 0 
          {  
          CurWobble += uiWobbleSpeed;
          if CurWobble &gt; uiWobble  {uiWobbleSpeed *= -1;}                                       
          else if CurWobble &lt; (uiWobble * -1)  {uiWobbleSpeed *= -1;}
          }    
          
     if uiPulse != 0
         {
          CurPulse += uiPulseSpeed;
          if CurPulse &gt; 1+(uiPulse) {uiPulseSpeed *= -1;}
          else if CurPulse &lt; 1-(uiPulse) {uiPulseSpeed *= -1;}          
         } 
         
     if uiFading != 0
         {
          CurFading += uiFadingSpeed;
          if CurFading &gt; 1 {uiFadingSpeed *= -1;}
          else if CurFading &lt; 1-(uiFading) {uiFadingSpeed *= -1;}          
         }             
  

  

    
}     //if has animated things like pulse, fading, etc...
    

if uiFadeOut CurFading=(1-uiAlpha);
  

 {     
       ymargin= (sprite_height - (string_height(CurDispText) * uiYscale)) div 2 ;
       px=x;
       if uiAlignAni==fa_left { px=x +5; } 
         else if uiAlignAni==fa_center {px= x + (( sprite_width-(string_width(CurDispText) * uiYscale)) div 2); }
            else if uiAlignAni==fa_right {px = x + sprite_width - (string_width(CurDispText) * uiYscale) -8; } 
       curp=px;
       for (fx=CurStartIndex;fx&lt;=tw;fx+=1)
            {
                   dc = uiCArray[fx];
                   uiCArrayXpos[fx]=curp;
                   uiCArrayYpos[fx]=y+ymargin;
                   curp += ceil(string_width(dc)*uiCArrayZoom[fx]);
            } 
 
 }  //no path assigned;
 

if (uiZoomFactor==0.1) || (uiVisible==false) exit;  //for zooming     


curZoomFactor=uiZoomFactor+uiAniPulse;
curAlpha=uiAlpha-uiAniFading;
curRot=uiAngle+uiAniWobble;

curXscale=uiXscale+uiAniPulse;
curYscale=uiYscale+uiAniPulse;


draw_set_font(uiFont);
draw_set_halign(uiAlign);
draw_set_valign(uiAlignV);
//draw_set_alpha(curAlpha);


if (uiAniPulse != 0)  &amp;&amp; (uiPulseJello)
   { if uiAniPulse &gt;= 0  {curYscale=(uiYscale)-uiAniPulse;}
               else      {curXscale=(uiXscale)-uiAniPulse;}
   }  
             

if (lasttext!=uiTextValue) //|| (uiAniPulse!=0)  //if string is too long we need to wordwrap
 { 
  lasttext=uiTextValue;  //keep copy to see if changed.

//  if ((string_width(uiTextValue+'X') * curXscale) &gt; (sprite_width)) 
  if ((string_width(uiTextValue+'X')) &gt; (sprite_width))   
   {
     event_user(1); //breaks apart string into items array;
   } else 
       {multLines=false;  //reset if one line fits....
        items=0;
        items[0]=uiTextValue;
        numitems=1;
        };         
 }


if multLines==false {items[0]=uiTextValue;}    //if just one line then just set one array item;


lh=(string_height('XgpT')*curYscale);   //lineheight;
uiCurHeight=(numitems * (lh+uiLineSpacing));  //info only for other controls.



if uiDrawBackColor 
   {
    draw_roundrect_color_ext(x, y, x+sprite_width, y+sprite_height, uiRadiusX,uiRadiusY,uiBackColor,uiBackColor, false);   //fill
   } 

//if (uiCenterWrap) || (numitems=1) {ymargin= (sprite_height - (uiCurHeight * curYscale)) div 2 ;} else {ymargin=0;}  //center in area or top
ymargin = 5; // JAMES - MATCHES BELOW
 
if uiAlign==fa_left { px=x +5; } 
 else if uiAlign==fa_middle {px= x + (sprite_width div 2); }
   else if uiAlign==fa_right {px = x+sprite_width -8; } 

   
cury=y+ymargin;

if uiTextEffect==3  //Type Keypress effect;
    { 
      if (CurAniCounter mod (room_speed div uiTypeSpeed))==1 CurTypeIndex+=1;
      for (fx=1;fx&lt;=tw;fx+=1)  // apply to all characters same;
       {   if fx&gt;=CurTypeIndex {uiCArrayAlpha[fx]=0} else {uiCArrayAlpha[fx]=1;}
       }
    }
   
   
if uiDrawOutlines&gt;0   //draw shadows
   {
    draw_set_color(uiBackColor2);  
     for (fg=1;fg&lt;=uiDrawOutlines;fg+=1)  
       {
        for (fx=0;fx&lt;numitems;fx+=1)   
          {  disptx=items[fx];
             draw_text_transformed(px,cury-fg,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px,cury+fg,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px+fg,cury,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px-fg,cury,disptx,curXscale,curYscale,curRot);                
             draw_text_transformed(px+fg,cury+fg,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px-fg,cury-fg,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px+fg,cury-fg,disptx,curXscale,curYscale,curRot);   
             draw_text_transformed(px-fg,cury+fg,disptx,curXscale,curYscale,curRot);                
             
             cury=cury+lh+uiLineSpacing;     
          }           
        cury=y+ymargin;    
       }   
   }
   
if uiDrawShadows&gt;0   //draw shadows
   {
    draw_set_color(uiBackColor2);  
     for (fg=1;fg&lt;=uiDrawShadows;fg+=1)  
       {
        for (fx=0;fx&lt;numitems;fx+=1)   
          {  disptx=items[fx];
             draw_text_transformed(px+fg,cury+fg,disptx,curXscale,curYscale,curRot);               
             cury=cury+lh+uiLineSpacing;     
          }           
        cury=y+ymargin;    
       }   
   }   
   


cury=y+ymargin;   

for (fx=0;fx&lt;numitems;fx+=1)   
  {  disptx=items[fx];
     draw_set_color(uiTextColor);  
//     draw_text_transformed(px,cury,disptx,curXscale,curYscale,curRot);
//use alpha for keyboard typewriter effect...
for (fx=CurStartIndex;fx&lt;=tw;fx+=1)  //draw each character individually...
{c1=uiCArrayColor[fx];
 if uiFadeOut uiCArrayAlpha[fx]=uiAlpha;
 draw_text_transformed_color(uiCArrayXpos[fx],uiCArrayYpos[fx],string_char_at(disptx,fx),uiCArrayZoom[fx], uiCArrayZoom[fx], uiCArrayRot[fx], c1, c1, c1, c1, uiCArrayAlpha[fx]);
 show_debug_message(string_char_at(disptx,fx));
 
 } 
     cury=cury+lh+uiLineSpacing;     
  }   

draw_set_alpha(backalpha);  //restore alpha (in case of fadeout, etc    
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
